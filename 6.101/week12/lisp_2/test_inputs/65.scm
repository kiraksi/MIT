(define (empty? list_) (equal? (length list_) 0))
(define (map func list_) (if (empty? list_) (list) (append (list (func (car list_))) (map func (cdr list_)))))
(define (reduce func list_ start) (if (empty? list_) start (reduce func (cdr list_) (func start (car list_)))))
(define (range start stop) (if (>= start stop) nil (cons start (range (+ start 1) stop))))
(define (all values) (if (equal? (length values) 0) #t (and (car values) (all (cdr values)))))
(define (min a b) (if (< a b) a b))
(define (max a b) (if (> a b) a b))
(define (zip a b) (if (or (equal? (length a) 0) (equal? (length b) 0)) nil (cons (cons (car a) (car b)) (zip (cdr a) (cdr b)))))
(define (set-list-ref ll index value) (if (equal? index 0) (cons value (cdr ll)) (cons (car ll) (set-list-ref (cdr ll) (- index 1) value))))
(define (initialize-nd dimensions value) (if (equal? (length dimensions) 0) value (map (lambda (_) (initialize-nd (cdr dimensions) value)) (range 0 (car dimensions)))))
(define (neighbors-nd dimensions coordinates) (if (equal? (length dimensions) 0) (list (list)) (reduce append (map (lambda (suffix) (map (lambda (prefix) (append (list prefix) suffix)) (range (max 0 (- (car coordinates) 1)) (min (car dimensions) (+ (car coordinates) 2))))) (neighbors-nd (cdr dimensions) (cdr coordinates))) (list))))
(define (get-nd board coordinates) (if (equal? (length coordinates) 1) (list-ref board (car coordinates)) (get-nd (list-ref board (car coordinates)) (cdr coordinates))))
(define (set-nd board coordinates value) (if (equal? (length coordinates) 1) (set-list-ref board (car coordinates) value) (set-list-ref board (car coordinates) (set-nd (list-ref board (car coordinates)) (cdr coordinates) value))))
(define (is-victory board mask dimensions) (if (equal? (length dimensions) 0) (or mask (equal? board -1)) (all (map (lambda (cons) (is-victory (car cons) (cdr cons) (cdr dimensions))) (zip board mask)))))
(define (game-get-state game) ((list-ref game 0)))
(define (game-set-state game state) ((list-ref game 1) state))
(define (game-get-board game) ((list-ref game 2)))
(define (game-set-board game board) ((list-ref game 3) board))
(define (game-get-mask game) ((list-ref game 4)))
(define (game-set-mask game mask) ((list-ref game 5) mask))
(define (game-get-dimensions game) ((list-ref game 6)))
(define (new-game-nd dimensions bombs) (begin (define state 0) (define board (initialize-nd dimensions 0)) (define mask (initialize-nd dimensions #f)) (define self (list (lambda () state) (lambda (new_state) (set! state new_state)) (lambda () board) (lambda (new_board) (set! board new_board)) (lambda () mask) (lambda (new_mask) (set! mask new_mask)) (lambda () dimensions))) (map (lambda (bomb) (begin (game-set-board self (set-nd (game-get-board self) bomb -1)) (map (lambda (neighbor) (begin (define value (get-nd (game-get-board self) neighbor)) (if (>= value 0) (game-set-board self (set-nd (game-get-board self) neighbor (+ value 1))) nil))) (neighbors-nd dimensions bomb)))) bombs) self))
(define (dig-nd game coordinates) (if (or (get-nd (game-get-mask game) coordinates) (not (equal? (game-get-state game) 0))) 0 (if (equal? (get-nd (game-get-board game) coordinates) -1) (begin (game-set-mask game (set-nd (game-get-mask game) coordinates #t)) (game-set-state game 2) 1) (begin (define (dig-helper coordinates) (if (get-nd (game-get-mask game) coordinates) 0 (begin (game-set-mask game (set-nd (game-get-mask game) coordinates #t)) (if (equal? (get-nd (game-get-board game) coordinates) 0) (reduce + (map (lambda (neighbor) (dig-helper neighbor)) (neighbors-nd (game-get-dimensions game) coordinates)) 1) 1)))) (define count (dig-helper coordinates)) (if (is-victory (game-get-board game) (game-get-mask game) (game-get-dimensions game)) (game-set-state game 1) nil) count))))
